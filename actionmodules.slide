Advanced Ansible
Action Modules for Fun And Profit

Henry Finucane

* 

.image actionmodules/ansible_badge.png

- Chef, Puppet, Salt, competitor
- Describe state
- Core in Python, you work in YAML

* YAML

Great at lists

    - apt: pkg=nginx

    - file: path=/var/run/lockfile state=absent

* YAML

Great at lists

    - apt: pkg=nginx

    - file: path=/var/run/lockfile state=absent

JSON for scale:

    [ { "apt": "pkg=nginx" }, { "file": "/var/run/lockfile state=absent" } ]

* YAML

Great at *data*

    nginx:
      port: 443
      ssl:
        enable: True
        certificate: /etc/nginx/ssl/hostname.cert


* Python

    if os.path.exists('/run/mysql.pid'):
        subprocess.call(['mysqladmin', 'shutdown'])

* YAML

    - stat: path=/run/mysql.pid
      register: mysql_pid

    - command: mysqladmin shutdown
      when: mysql_pid|exists

* Python & YAML

    if os.path.exists('/run/mysql.pid'):
        subprocess.call(['mysqladmin', 'shutdown'])

vs

    - stat: path=/run/mysql.pid
      register: mysql_pid

    - command: mysqladmin shutdown
      when: mysql_pid|exists

* YAML

Logic becomes awkward fast

- `register:` everything
- No visual grouping
- Integration-testing only

* YAML

Logic is actually pretty inefficient

    - foo: a=x b=y
      register: foo_result

    - bar: dest=z
      when: foo_result|changed

* YAML

    - foo: a=x b=y
      register: foo_result

    - bar: dest=z
      when: foo_result|changed

- Ship foo to the remote host
- Execute foo
- Ship results back, parse, evaluate when
- Conditionally ship bar
- Conditionally execute bar

* YAML

Including a long task many times will scale poorly

* YAML

Including a long task many times will scale poorly

Ansible is pretty fast

* YAML

Including a long task many times will scale poorly

Ansible is pretty fast

This is a terrible reason to make decisions

* YAML

Including a long task many times will scale poorly

Ansible is pretty fast

This is a terrible reason to make decisions

Sometimes it has to happen

* Modules

* Modules Are Great

* Really easy to write

- A script that returns json
- Ansible has a bunch of helper libraries

* Modules can't do everything

They run on the host you are deploying to

You can work around this:

   - fetch: http://internal_repo/bar.deb
     local_action: True

But if you're going to do this a lot...

* Modules can't run on the host and the remote

There's always

    - complicated_fetch: http://wubwubwub/dubstep
      register: cf

    - synchronize: src={{cf|dest}} dest=/var/tmp/cf

    - setup: src=/var/tmp/cf

* Warning: Theorizing ahead

* API Matters

- DevOps is not just making sure that someone can push 'play'

* API Matters

- DevOps is not just making sure that someone can push 'play'
- LL has a lot of small teams that do slightly different deployments- the nature of our work

* API Matters

- DevOps is not just making sure that someone can push 'play'
- LL has a lot of small teams that do slightly different deployments- the nature of our work
- Tooling for Ansible should be legible & native seeming

* API Matters

If you have a bad API, eventually, your work will get re-implemented

* API Matters

If you have a bad API, eventually, your work will get re-implemented

It's really easy to do simple deployment things wrong

* API Matters

If you have a bad API, eventually, your work will get re-implemented

It's really easy to do simple deployment things wrong

The kind of wrong that works just fine in most circumstances

* 

.image actionmodules/segway.jpg

* Action Plugins Are Amazing

Action Plugins can do anything

- Coalesce multiple modules into a single piece of API
- Modify transport parameters
- Change transports
- Turn off check mode, and run modules[1]
- Monkeypatch Ansible[2]

[1]: Presumably, because you are a monster
[2]: Honestly this is probably a bad idea

* Template

Have you ever wondered how it works?

- Render on your machine ( no need to install Jinja2 on the remote )

* Template

Have you ever wondered how it works?

- Render on your machine ( no need to install Jinja2 on the remote )
- Figures out if it needs to do anything, maybe spits out a diff

* Template

Have you ever wondered how it works?

- Render on your machine ( no need to install Jinja2 on the remote )
- Figures out if it needs to do anything, maybe spits out a diff
- Copies the template to a temporary directory on the remote

* Template

Have you ever wondered how it works?

- Render on your machine ( no need to install Jinja2 on the remote )
- Figures out if it needs to do anything, maybe spits out a diff
- Copies the template to a temporary directory on the remote
- Asks the `copy` module to finish the task

* Template

Have you ever wondered how it works?

    # template the source data locally & get ready to transfer
    resultant = self._templar.template(template_data, preserve_trailing_newlines=True, escape_backslashes=False, convert_data=False)
    ...
    result.update(self._execute_module(module_name='copy', module_args=new_module_args, task_vars=task_vars, tmp=tmp, delete_remote_tmp=False))
    ...
    if result.get('changed', False) and self._play_context.diff:
        result['diff'] = diff
    return result


* Hello World

in action_plugins/hello.py:

    from ansible.runner.return_data import ReturnData
    
    class ActionModule(object):
        def __init__(self, runner):
            self.runner = runner
    
        def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs):
            return ReturnData(conn=conn,
                              comm_ok=True,
                              result=dict(failed=False, changed=False, msg="Hello World"))

* Hello World

in action_plugins/hello.py:

    from ansible.plugins.action import ActionBase

    class ActionModule(ActionBase):
        def run(self, tmp=None, task_vars=None):
            return dict(msg="Hello World", _ansible_verbose_always=True)


a file called library/hello

* Hello World

    $ ansible all -i localhost, -m hello
    
    localhost | success >> {
        "changed": false, 
        "failed": false, 
        "msg": "Hello World"
    }

* action_plugins & library?

An action plugin must have a module with the same name

You can divide the work into action plugin/module concerns

* action_plugins & library?

An action plugin must have a module with the same name

You can also divide the work into action plugin/module concerns

`copy` does this.

* Tying Action Plugins Together

    from ansible.plugins.action.synchronize import ActionModule as Sync

* Tying Action Plugins Together

    from ansible.plugins.action.synchronize import ActionModule as Sync


Usage requires some boilerplate:

    sync = Sync(self._task,
                self._connection,
                self._play_context,
                self._loader,
                self._templar,
                self._shared_loader_obj)
    sync_result = sync.run(tmp=tmp, task_vars=task_vars)

* Accessing global variables

I don't have a non-hacky method for this in Ansible 2, but the following will work:

* Accessing global variables

    all_variables = self._templar.template('{{vars}}')

* Accessing global variables

    all_variables = self._templar.template('{{vars}}')

This abuses Ansible's support for `debug: var=vars`, so it's likely to keep
working, but asking the templating system to give you the current context, and
assuming it will come out as a structure instead of a string is a definitely
straddling a line.

* Logging

First step, get access to the current logging object, called "display"

    try:
        from __main__ import display
    except ImportError:
        from ansible.utils.display import Display
        display = Display()

* Logging

    display.vv('log a message')
    display.vvv('log something maybe a bit less important')

Corresponds to `-vv` or `-vvv` on the command line.

* Logging

You can support arbitrarily large numbers of Vs

    display.verbose("Super custom verbosity", caplevel=42)

* Diff mode

Ansible 2.0 supports diff mode in regular modules:

    #!/usr/bin/python

    print r'{"failed": false, "changed": true, "diff": {"before": "fee\nfo\nfum\n", "after": "fee\nfi\nfum\n"}}'

gives you

    changed: [localhost]
    --- before
    +++ after
    @@ -1,3 +1,3 @@
     fee
    -fo
    +fi
     fum


* Diff mode

Everything is done above the level of an individual action module, so you don't
have to do anything special here either:

    class ActionModule(ActionBase):
        def run(self, tmp=None, task_vars=None):
            # If there's no change, Ansible assumes there can be no diff
            return {'changed': True, 'diff': { 'before': 'foo\nbar', 'after': 'bar' } }


Gives you

    --- before
    +++ after
    @@ -1,2 +1 @@
    -foo
     bar
    ok: [localhost]


* Connection Magic

The synchronize action module will actually change your transport in flight:

    if not use_delegate and remote_transport:
        new_stdin = self._connection._new_stdin
        ...
        new_connection = connection_loader.get('local', self._play_context, new_stdin)
        self._connection = new_connection

    ... 
    self._execute_module('synchronize', task_vars=task_vars)


* Connection Magic

Wait, what?

    $ ansible all -i localhost, -m file -a "path=/var/tmp/x state=present"
    localhost | FAILED => SSH encountered an unknown error during the connection. We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue
    $ ssh localhost
    ssh: connect to host localhost port 22: Connection refused
    $ ansible all -i localhost, -c local -m file -a "path=/var/tmp/x state=present"


* Connection Magic for SSH

Super-duper-bulletproof iptables application

    - apply: src=/etc/iptables/iptables.v4
    - apply_confirm:

* Connection Magic for SSH

`ControlPersist`

Ansible's speed secret sauce

Turning it off is, broadly, not a great idea

In ansible.cfg:

    ssh_args = -o ControlMaster=auto -o ControlPersist=60s

* Connection Magic for SSH

Run ping, but with no ControlPersist:

    class ActionModule(ActionBase):
        def run(self, tmp=None, task_vars=None):
            self._play_context.ssh_args = ''
            result = self._execute_module('ping', task_vars=task_vars)
            return result
